# SPDX-License-Identifier: MIT interface IERC20: def transfer(to: address, amount: uint256) -> bool: nonpayable def transferFrom(sender: address, to: address, amount: uint256) -> bool: nonpayable def approve(spender: address, amount: uint256) -> bool: nonpayable interface AggregatorV3Interface: def latestAnswer() -> int256: view struct Offer: id: uint256 creator: address token: address amount: uint256 fiat_price: uint256 fiat_type: String[10] payment_method: String[50] active: bool acceptor: address payment_confirmed: bool created_at: uint256 offers: public(DynArray[Offer, 1000]) oracle: public(address) owner: public(address) next_offer_id: uint256 escrow_balances: HashMap[uint256, uint256] fee_bps: public(uint256) # Fee in basis points (e.g., 30 = 0.3%) fee_recipient: public(address) total_fees_collected: public(HashMap[address, uint256]) # Fees collected per token (or ETH) event OfferCreated: id: uint256 creator: address token: address amount: uint256 fiat_price: uint256 fiat_type: String[10] payment_method: String[50] event OfferAccepted: id: uint256 acceptor: address amount: uint256 fiat_type: String[10] event PaymentConfirmed: id: uint256 payment_confirmed: bool fee_amount: uint256 fee_token: address event FeeRecipientUpdated: new_recipient: address event FeeBpsUpdated: new_fee_bps: uint256 @external def __init__(oracle: address): self.oracle = oracle self.owner = msg.sender self.next_offer_id = 1 self.fee_bps = 30 # Default 0.3% (30 basis points) self.fee_recipient = msg.sender @external def set_fee_recipient(new_recipient: address): assert msg.sender == self.owner, "Only owner" assert new_recipient != empty(address), "Invalid recipient" self.fee_recipient = new_recipient log FeeRecipientUpdated(new_recipient) @external def set_fee_bps(new_fee_bps: uint256): assert msg.sender == self.owner, "Only owner" assert new_fee_bps <= 1000, "Fee too high" # Max 10% self.fee_bps = new_fee_bps log FeeBpsUpdated(new_fee_bps) @external @payable @nonreentrant("lock") def create_offer(token: address, amount: uint256, fiat_price: uint256, fiat_type: String[10], payment_method: String[50]): assert amount > 0 and fiat_price > 0, "Invalid amount or price" assert len(fiat_type) > 0 and len(payment_method) > 0, "Invalid fiat type or payment method" fee_amount: uint256 = (amount * self.fee_bps) / 10000 assert amount > fee_amount, "Amount too low to cover fee" if token == empty(address): assert msg.value == amount, "Incorrect ETH amount" self.escrow_balances[self.next_offer_id] = amount - fee_amount if fee_amount > 0: send(self.fee_recipient, fee_amount) self.total_fees_collected[empty(address)] += fee_amount else: assert IERC20(token).transferFrom(msg.sender, self, amount), "Token transfer failed" if fee_amount > 0: assert IERC20(token).transfer(self.fee_recipient, fee_amount), "Fee transfer failed" self.escrow_balances[self.next_offer_id] = amount - fee_amount self.total_fees_collected[token] += fee_amount self.offers.append(Offer({ id: self.next_offer_id, creator: msg.sender, token: token, amount: amount - fee_amount, fiat_price: fiat_price, fiat_type: fiat_type, payment_method: payment_method, active: True, acceptor: empty(address), payment_confirmed: False, created_at: block.timestamp })) log OfferCreated(self.next_offer_id, msg.sender, token, amount - fee_amount, fiat_price, fiat_type, payment_method) self.next_offer_id += 1 @external @payable @nonreentrant("lock") def accept_offer(offer_id: uint256): assert offer_id > 0 and offer_id <= len(self.offers), "Invalid offer ID" offer: Offer = self.offers[offer_id - 1] assert offer.active, "Offer is not active" assert offer.acceptor == empty(address), "Offer already accepted" self.offers[offer_id - 1].acceptor = msg.sender self.offers[offer_id - 1].active = False log OfferAccepted(offer_id, msg.sender, offer.amount, offer.fiat_type) @external @nonreentrant("lock") def confirm_fiat_payment(offer_id: uint256, payment_confirmed: bool): assert offer_id > 0 and offer_id <= len(self.offers), "Invalid offer ID" offer: Offer = self.offers[offer_id - 1] assert not offer.active, "Offer is still active" assert msg.sender == offer.creator or msg.sender == offer.acceptor, "Unauthorized" assert not offer.payment_confirmed, "Payment already confirmed" assert block.timestamp < offer.created_at + 24 * 3600, "Dispute period expired" self.offers[offer_id - 1].payment_confirmed = True fee_amount: uint256 = (offer.amount * self.fee_bps) / 10000 transfer_amount: uint256 = offer.amount - fee_amount if payment_confirmed: if offer.token == empty(address): if fee_amount > 0: send(self.fee_recipient, fee_amount) self.total_fees_collected[empty(address)] += fee_amount send(offer.acceptor, transfer_amount) else: if fee_amount > 0: assert IERC20(offer.token).transfer(self.fee_recipient, fee_amount), "Fee transfer failed" self.total_fees_collected[offer.token] += fee_amount assert IERC20(offer.token).transfer(offer.acceptor, transfer_amount), "Token transfer failed" else: if offer.token == empty(address): if fee_amount > 0: send(self.fee_recipient, fee_amount) self.total_fees_collected[empty(address)] += fee_amount send(offer.creator, transfer_amount) else: if fee_amount > 0: assert IERC20(offer.token).transfer(self.fee_recipient, fee_amount), "Fee transfer failed" self.total_fees_collected[offer.token] += fee_amount assert IERC20(offer.token).transfer(offer.creator, transfer_amount), "Token transfer failed" self.escrow_balances[offer_id] = 0 log PaymentConfirmed(offer_id, payment_confirmed, fee_amount, offer.token)
