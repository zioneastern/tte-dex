# SPDX-License-Identifier: MIT interface IERC20: def transfer(to: address, amount: uint256) -> bool: nonpayable def transferFrom(sender: address, to: address, amount: uint256) -> bool: nonpayable def approve(spender: address, amount: uint256) -> bool: nonpayable def balanceOf(account: address) -> uint256: view def allowance(owner: address, spender: address) -> uint256: view def totalSupply() -> uint256: view name: public(String[32]) symbol: public(String[10]) decimals: public(uint8) total_supply: public(uint256) balances: HashMap[address, uint256] allowances: HashMap[address, HashMap[address, uint256]] owner: public(address) paused: public(bool) dex_address: public(address) # TTEDex contract address fee_recipient: public(address) # Recipient of 2.3% sell tax sell_tax_bps: public(uint256) # 2.3% tax (230 basis points) total_fees_collected: public(uint256) # Total TTE fees collected locked_tokens: public(HashMap[String[20], uint256]) # Locked amounts ("four_year" or "game") four_year_lock_end: public(uint256) # Timestamp for 4-year lock (June 29, 2029) four_year_release_end: public(uint256) # Timestamp for full release (June 29, 2030) tax_exempt: HashMap[address, bool] # Addresses exempt from sell tax event Transfer: sender: indexed(address) receiver: indexed(address) amount: uint256 event Approval: owner: indexed(address) spender: indexed(address) amount: uint256 event Pause: paused: bool event OwnershipTransferred: previous_owner: indexed(address) new_owner: indexed(address) event FeeRecipientUpdated: new_recipient: address event DexAddressUpdated: new_dex_address: address event TaxExemptionUpdated: account: address exempt: bool event FourYearTokensReleased: amount: uint256 released_to: address event GameTokensUnlocked: amount: uint256 released_to: address @external def __init__(dex_address: address): self.name = "TTE Token" self.symbol = "TTE" self.decimals = 18 self.total_supply = 1_000_000 * 10**18 # 1,000,000 TTE self.owner = msg.sender self.dex_address = dex_address self.fee_recipient = msg.sender self.sell_tax_bps = 230 # 2.3% tax on DEX sells self.paused = False self.tax_exempt[msg.sender] = True # Owner exempt from tax by default # Allocate tokens self.balances[msg.sender] = 800_000 * 10**18 # 500,000 (mining) + 300,000 (open market) self.locked_tokens["four_year"] = 100_000 * 10**18 # 100,000 TTE locked for 4 years self.locked_tokens["game"] = 100_000 * 10**18 # 100,000 TTE locked for P2E game self.four_year_lock_end = block.timestamp + 4 * 365 * 24 * 3600 # ~June 29, 2029 self.four_year_release_end = self.four_year_lock_end + 365 * 24 * 3600 # ~June 29, 2030 log Transfer(empty(address), msg.sender, 800_000 * 10**18) @external def set_dex_address(new_dex_address: address): assert msg.sender == self.owner, "Only owner" assert new_dex_address != empty(address), "Invalid address" self.dex_address = new_dex_address log DexAddressUpdated(new_dex_address) @external def set_fee_recipient(new_recipient: address): assert msg.sender == self.owner, "Only owner" assert new_recipient != empty(address), "Invalid recipient" self.fee_recipient = new_recipient log FeeRecipientUpdated(new_recipient) @external def set_tax_exempt(account: address, exempt: bool): assert msg.sender == self.owner, "Only owner" assert account != empty(address), "Invalid address" self.tax_exempt[account] = exempt log TaxExemptionUpdated(account, exempt) @external def pause(): assert msg.sender == self.owner, "Only owner" self.paused = True log Pause(True) @external def unpause(): assert msg.sender == self.owner, "Only owner" self.paused = False log Pause(False) @external def transfer_ownership(new_owner: address): assert msg.sender == self.owner, "Only owner" assert new_owner != empty(address), "Invalid address" old_owner: address = self.owner self.owner = new_owner self.tax_exempt[new_owner] = True # New owner inherits tax exemption self.tax_exempt[old_owner] = False log OwnershipTransferred(old_owner, new_owner) log TaxExemptionUpdated(new_owner, True) log TaxExemptionUpdated(old_owner, False) @external @nonreentrant("lock") def transfer(to: address, amount: uint256) -> bool: assert not self.paused, "Contract paused" assert to != empty(address), "Invalid address" assert self.balances[msg.sender] >= amount, "Insufficient balance" fee_amount: uint256 = 0 transfer_amount: uint256 = amount if to == self.dex_address and not self.tax_exempt[msg.sender]: fee_amount = (amount * self.sell_tax_bps) / 10_000 # 2.3% tax transfer_amount = amount - fee_amount assert transfer_amount > 0, "Amount too low to cover fee" self.balances[msg.sender] -= amount self.balances[to] += transfer_amount if fee_amount > 0: self.balances[self.fee_recipient] += fee_amount self.total_fees_collected += fee_amount log Transfer(msg.sender, self.fee_recipient, fee_amount) log Transfer(msg.sender, to, transfer_amount) return True @external @nonreentrant("lock") def transferFrom(sender: address, to: address, amount: uint256) -> bool: assert not self.paused, "Contract paused" assert to != empty(address), "Invalid address" assert self.balances[sender] >= amount, "Insufficient balance" assert self.allowances[sender][msg.sender] >= amount, "Insufficient allowance" fee_amount: uint256 = 0 transfer_amount: uint256 = amount if to == self.dex_address and not self.tax_exempt[sender]: fee_amount = (amount * self.sell_tax_bps) / 10_000 # 2.3% tax transfer_amount = amount - fee_amount assert transfer_amount > 0, "Amount too low to cover fee" self.balances[sender] -= amount self.balances[to] += transfer_amount self.allowances[sender][msg.sender] -= amount if fee_amount > 0: self.balances[self.fee_recipient] += fee_amount self.total_fees_collected += fee_amount log Transfer(sender, self.fee_recipient, fee_amount) log Transfer(sender, to, transfer_amount) return True @external def approve(spender: address, amount: uint256) -> bool: assert not self.paused, "Contract paused" assert spender != empty(address), "Invalid address" self.allowances[msg.sender][spender] = amount log Approval(msg.sender, spender, amount) return True @external @view def balanceOf(account: address) -> uint256: return self.balances[account] @external @view def allowance(owner: address, spender: address) -> uint256: return self.allowances[owner][spender] @external @view def totalSupply() -> uint256: return self.total_supply @external def release_four_year_tokens(to: address): assert block.timestamp >= self.four_year_lock_end, "Tokens still locked" assert to != empty(address), "Invalid address" locked_amount: uint256 = self.locked_tokens["four_year"] assert locked_amount > 0, "No tokens to release" seconds_passed: uint256 = block.timestamp - self.four_year_lock_end vesting_duration: uint256 = self.four_year_release_end - self.four_year_lock_end releasable_fraction: uint256 = min(seconds_passed * 10**18 / vesting_duration, 10**18) releasable_amount: uint256 = (locked_amount * releasable_fraction) / 10**18 if releasable_amount > 0: self.locked_tokens["four_year"] -= releasable_amount self.balances[to] += releasable_amount log FourYearTokensReleased(releasable_amount, to) log Transfer(empty(address), to, releasable_amount) @external def unlock_game_tokens(to: address, amount: uint256): assert msg.sender == self.owner, "Only owner" assert to != empty(address), "Invalid address" assert self.locked_tokens["game"] >= amount, "Insufficient locked tokens" self.locked_tokens["game"] -= amount self.balances[to] += amount log GameTokensUnlocked(amount, to) log Transfer(empty(address), to, amount)