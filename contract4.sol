# SPDX-License-Identifier: MIT interface IERC20: def transfer(to: address, amount: uint256) -> bool: nonpayable def transferFrom(sender: address, to: address, amount: uint256) -> bool: nonpayable def approve(spender: address, amount: uint256) -> bool: nonpayable def balanceOf(account: address) -> uint256: view struct Pool: token0: address token1: address reserve0: uint256 reserve1: uint256 exists: bool pools: public(HashMap[String[20], Pool]) owner: public(address) event PoolCreated: pair: String[20] token0: address token1: address event Swap: pair: String[20] sender: address amount0_in: uint256 amount1_in: uint256 amount0_out: uint256 amount1_out: uint256 event LiquidityAdded: pair: String[20] sender: address amount0: uint256 amount1: uint256 event LiquidityRemoved: pair: String[20] sender: address amount0: uint256 amount1: uint256 @external def __init__(): self.owner = msg.sender @external def create_pool(pair: String[20], token0: address, token1: address): assert msg.sender == self.owner, "Only owner can create pool" assert len(pair) > 0, "Pair name cannot be empty" assert not self.pools[pair].exists, "Pool already exists" assert token0 != empty(address) and token1 != empty(address), "Invalid token address" self.pools[pair] = Pool({ token0: token0, token1: token1, reserve0: 0, reserve1: 0, exists: True }) log PoolCreated(pair, token0, token1) @external @view def get_reserves(pair: String[20]) -> (uint256, uint256): pool: Pool = self.pools[pair] assert pool.exists, "Pool does not exist" return (pool.reserve0, pool.reserve1) @external @view def pool_exists(pair: String[20]) -> bool: return self.pools[pair].exists @external @nonreentrant("lock") def swap(pair: String[20], amount0_in: uint256, amount1_in: uint256): pool: Pool = self.pools[pair] assert pool.exists, "Pool does not exist" assert (amount0_in > 0 and amount1_in == 0) or (amount0_in == 0 and amount1_in > 0), "Invalid input amounts" amount0_out: uint256 = 0 amount1_out: uint256 = 0 if amount0_in > 0: amount1_out = (pool.reserve1 * amount0_in * 997) / (pool.reserve0 * 1000 + amount0_in * 997) assert amount1_out > 0 and amount1_out <= pool.reserve1, "Insufficient reserve1" assert IERC20(pool.token0).transferFrom(msg.sender, self, amount0_in), "Token0 transfer failed" assert IERC20(pool.token1).transfer(msg.sender, amount1_out), "Token1 transfer failed" self.pools[pair].reserve0 += amount0_in self.pools[pair].reserve1 -= amount1_out else: amount0_out = (pool.reserve0 * amount1_in * 997) / (pool.reserve1 * 1000 + amount1_in * 997) assert amount0_out > 0 and amount0_out <= pool.reserve0, "Insufficient reserve0" assert IERC20(pool.token1).transferFrom(msg.sender, self, amount1_in), "Token1 transfer failed" assert IERC20(pool.token0).transfer(msg.sender, amount0_out), "Token0 transfer failed" self.pools[pair].reserve1 += amount1_in self.pools[pair].reserve0 -= amount0_out log Swap(pair, msg.sender, amount0_in, amount1_in, amount0_out, amount1_out) @external @nonreentrant("lock") def add_liquidity(pair: String[20], amount0: uint256, amount1: uint256): pool: Pool = self.pools[pair] assert pool.exists, "Pool does not exist" assert amount0 > 0 and amount1 > 0, "Invalid amounts" if pool.reserve0 > 0 and pool.reserve1 > 0: current_ratio: uint256 = (pool.reserve0 * 10**18) / pool.reserve1 input_ratio: uint256 = (amount0 * 10**18) / amount1 assert current_ratio / 10**16 <= input_ratio and input_ratio <= current_ratio * 10**16, "Invalid liquidity ratio" assert IERC20(pool.token0).transferFrom(msg.sender, self, amount0), "Token0 transfer failed" assert IERC20(pool.token1).transferFrom(msg.sender, self, amount1), "Token1 transfer failed" self.pools[pair].reserve0 += amount0 self.pools[pair].reserve1 += amount1 log LiquidityAdded(pair, msg.sender, amount0, amount1) @external @nonreentrant("lock") def remove_liquidity(pair: String[20], amount0: uint256, amount1: uint256): pool: Pool = self.pools[pair] assert pool.exists, "Pool does not exist" assert amount0 <= pool.reserve0 and amount1 <= pool.reserve1, "Insufficient reserves" assert IERC20(pool.token0).transfer(msg.sender, amount0), "Token0 transfer failed" assert IERC20(pool.token1).transfer(msg.sender, amount1), "Token1 transfer failed" self.pools[pair].reserve0 -= amount0 self.pools[pair].reserve1 -= amount1 log LiquidityRemoved(pair, msg.sender, amount0, amount1)